rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Get user's organizationId
    function getUserOrgId() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.organizationId;
    }

    // Check if resource belongs to user's organization (multi-tenant isolation)
    function belongsToUserOrg() {
      return isAuthenticated() && 
        resource.data.organizationId == getUserOrgId();
    }

    // Check if new resource will belong to user's organization
    function willBelongToUserOrg() {
      return isAuthenticated() && 
        request.resource.data.organizationId == getUserOrgId();
    }

    // Check if user has 'admin' role in 'users' collection
    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Check if user is the specific customer (matches their UID in customers collection)
    function isCustomer(customerId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/customers/$(customerId)) &&
        get(/databases/$(database)/documents/customers/$(customerId)).data.uid == request.auth.uid;
    }

    // Check if user is a customer and owns the project (via customerId on resource)
    function isProjectOwner(resourceData) {
       return isAuthenticated() && 
         isCustomer(resourceData.customerId);
    }
    
    // --- Collection Rules ---

    // Users Collection (Roles)
    match /users/{userId} {
      allow read: if isAdmin() || (isAuthenticated() && request.auth.uid == userId);
      allow write: if isAdmin(); 
      allow create: if isAuthenticated() && request.auth.uid == userId; 
      allow update: if isAdmin() || (isAuthenticated() && request.auth.uid == userId);
    }

    // Customers Collection
    match /customers/{customerId} {
      allow read: if isAdmin() || isCustomer(customerId);
      allow write: if isAdmin(); 
      allow update: if isAdmin() || (isCustomer(customerId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['logoUrl', 'companyName', 'contactEmail']));
    }

    // Projects
    match /projects/{projectId} {
      allow read: if isAdmin() || isProjectOwner(resource.data);
      allow write: if isAdmin();
      // Allow customers to update basic fields if needed, currently leaving to admin only for write.
      // If customers need to update, add allow update rule here.
    }

    // Tasks
    match /tasks/{taskId} {
      allow read: if isAdmin() || isProjectOwner(resource.data);
      allow write: if isAdmin();
    }

    // Epics
    match /epics/{epicId} {
      allow read: if isAdmin() || isProjectOwner(resource.data);
      allow write: if isAdmin();
    }

    // Tickets
    match /tickets/{ticketId} {
      allow read: if isAdmin() || isCustomer(resource.data.customerId);
      allow create: if isAuthenticated() && 
        isCustomer(request.resource.data.customerId) &&
        request.resource.data.createdById == request.auth.uid;
      allow update: if isAdmin() || (
        isCustomer(resource.data.customerId) && 
        request.resource.data.customerId == resource.data.customerId
      );
    }

    // Project Requests
    match /project_requests/{requestId} {
      allow create: if true;
      allow read: if isAdmin() || (isAuthenticated() && resource.data.email == request.auth.token.email); // Only Admin or Creator (by email) checks
      allow update, delete: if isAdmin();
    }

    // Academy Bookings
    match /academy_bookings/{bookingId} {
      allow create: if true;
      allow read, update, delete: if isAdmin();
    }

    // Document Vault
    match /documents/{docId} {
      allow read, write: if isAdmin();
      
      allow read: if isAuthenticated() && 
        isCustomer(resource.data.customerId) && 
        resource.data.visibility != 'admin';
        
      allow create: if isAuthenticated() && 
        isCustomer(request.resource.data.customerId) &&
        request.resource.data.uploadedBy == 'customer';
        
       allow update, delete: if isAuthenticated() && 
         isCustomer(resource.data.customerId) &&
         resource.data.uploadedBy == 'customer'; 
    }

    // Knowledge Hub
    match /knowledge_articles/{articleId} {
      allow read: if true; 
      allow write: if isAdmin();
    }

    // Feature Flags & Labs
    match /feature_flags/{flagId} {
      allow read: if true; 
      allow write: if isAdmin();
    }

    // GDPR Deletion Requests
    match /deletion_requests/{requestId} {
      allow create: if isAuthenticated() && request.resource.data.customerId == request.auth.uid;
      allow read: if isAuthenticated() && resource.data.customerId == request.auth.uid;
      allow write: if isAdmin();
    }
    
    // Activity Log
    match /activity_log/{logId} {
      allow read: if isAdmin() || (isAuthenticated() && resource.data.customerId != null && isCustomer(resource.data.customerId));
      allow create: if isAdmin() || (isAuthenticated() && request.resource.data.actorId == request.auth.uid);
      allow update, delete: if false; 
    }

    // Site Content
    match /site_content/{docId} {
      allow read: if true; 
      allow write: if isAdmin();
    }
    
    // Customer Invites - SECURED: Prevent token enumeration and unauthorized updates
    match /customer_invites/{inviteId} {
       // Only allow reading invites for the authenticated user's email or admins
       allow read: if isAdmin() || (isAuthenticated() && resource.data.email == request.auth.token.email);
       
       // Only admin can create invites
       allow create: if isAdmin();
       
       // Allow accepting invite only if: email matches, invite is pending, and only changing status
       allow update: if isAuthenticated() && 
         resource.data.email == request.auth.token.email &&
         resource.data.status == 'pending' &&
         request.resource.data.status == 'accepted' &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'usedAt']);
       
       // Admin can do anything with invites
       allow write: if isAdmin();
    }
  }
}
